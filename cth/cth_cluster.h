/* Defs for cth clustering program.

   Modification History
   14-04-02  dale   Create
*/

#ifndef CTH_CLUSTER_H
#define CTH_CLUSTER_H

#define _FILE_OFFSET_BITS 64

#include <iostream>
#include <fstream>
#include <algorithm>
#include <string>
#include <sstream>
#include <iterator>
#include <iomanip>
#include <map>
#include <stack>
#include <array>
#include <vector>
#include <cfloat>
#include <cmath>
#include <stdlib.h>
#include <getopt.h>
#include <errno.h>
#include <ctype.h>
#include <libgen.h>

#include <eigen3/Eigen/Core>
#include <eigen3/Eigen/Dense>

#include <freexl.h>  // xls functions

using namespace std;
using namespace Eigen;

extern bool Debug;

const string CTH_VERSION="CTH file version 2.2";
const int E_MARKER=98;
const int I_MARKER=97;
const int MIN_CELL=100;
const int MAX_CELL=999;
const int MAX_CYCLE_TIME=30.0;  // reject cycles longer than this many secs
const int MIN_CYCLE_TIME=0.5;   // reject cycles shorter
/*
   adt file: each tick is 0.5 ms  0.0005 sec  500 us  5,000 ticks/sec
   bdt file: each tick is 0.5 ms  0.0005 sec  500 us  5,000 ticks/sec
   edt file: each tick is 0.1 ms  0.0001 sec  100 us 10,000 ticks/sec
*/
const double ADT_TICK=0.5;  // ms
const double BDT_TICK=0.5;
const double EDT_TICK=0.1;

// Octave per-cth struct size.  This is used several places
const char CTH_FIELDS[]="% length: 8";

// To ensure persistence between a cth and its sequence number,
// we use a text file that contains the cth's unique name and
// its assocated index number.
using CTHCurves = map<string,string>;
using CTHCurvesIter = CTHCurves::iterator;

// Some xls file handling stuff
const char *FILE_XLS1="all cells";  // Worksheet names in xls files
const char *FILE_XLS2="FILES";
const char *INFO_XLS1="Info File";
const char *INFO_XLS2="About Info File";
const string FILE_HEADER_START="path";
const string FILE_HEADER_END="notes";
const int  CURR_FORMAT = 25;  // # of tabs/fields 

enum F_TYPE { EDT, BDT, ADT };
enum NORM { MEAN, PEAK, NONE, UNIT};
enum XLS_TYPE { FILELIST=1,INFO};

// The control period generates just one set of CTHs.  If there are ctl/stim
// markers after that, they can generate 2, 4, or more CTHs "per period".
// To minimize changes to a lot of code, we treat the ctl and stim markers 
// as "periods".
// The enum should be sequential. We use a vector to hold the values, so
// this is not strictly the case.  MAX_PERIODS must be the largest value, though.
// *** If you change this, look at the period2str.m and drawbar.m functions in cthgui
// *** and also the brainstem code. At the time this was implemented, there was no
// *** period 9, so the octave and brainstem code used 9 for it's cs-delta pseudo-period.
// *** To be compatible with old .cth files, new real periods start at 10. There will
// *** never be a period 9 generated by this program.


enum CTL_STIMS {CTL_PERIOD=0, CTL_CCO2, STIM_CCO2, CTL_VCO2, STIM_VCO2, TB_CTL_CGH, TB_STIM_CGH, LAR_CTL_CGH, LAR_STIM_CGH, FAKE_CS_PERIOD, CTL_SWALL1, STIM_SWALL1,CTL_LAREFLEX,STIM_LAREFLEX,MAX_PERIODS};
const vector<CTL_STIMS> CtlStims = {CTL_PERIOD, CTL_CCO2, STIM_CCO2, CTL_VCO2, STIM_VCO2, TB_CTL_CGH, TB_STIM_CGH, LAR_CTL_CGH, LAR_STIM_CGH, FAKE_CS_PERIOD, CTL_SWALL1,STIM_SWALL1,CTL_LAREFLEX,STIM_LAREFLEX};
using P_LIST = vector<CTL_STIMS>;
const string PNames[] = {"_ctl","_cco2","_vco2","_tb_cgh","_lar_cgh","_swall1","_ctl_swall1","_ctl_lareflex","_lareflex","_allp"};
enum PNamesIdx {CTL_PER, CCO2_PER, VCO2_PER, TB_CGH_PER, LAR_CGH_PER, SWALL1_PER, CTL_SWALL1_PER, CTL_LAREFLEX_PER,STIM_LAREFLEX_PER,ALL_PER};


using ReMap = map<int,int>;         // remapping chans from older ?dt files
using ReMapIter= ReMap::iterator;

/* The input file list is an excel spreadsheet.  Many assumptions are made
   about the format of the spread.  Some fields in the main spread are paths
   and names to secondary spreads.
*/
class FileFacts
{
   public:
      FileFacts() {};

      double TimeVal(long time)  // given time in file units, return milliseconds
      {
         switch (ftype)
         {
            case BDT: return time * BDT_TICK; break;
            case EDT: return time * EDT_TICK; break;
            default: return time * ADT_TICK; break;
         }
      }

      double TickVal()  // in seconds
      {
         switch (ftype)
         {
            case BDT: return BDT_TICK; break;
            case EDT: return EDT_TICK; break;
            default: return ADT_TICK; break;
         }
      }
      void print() {
                     cout << "Path:            " << this->path << endl;
                     cout << "Fname:           " << this->fname << endl;
                     cout << "Period mark val: " << this->pmark << endl;
                     cout << "File Type:       " << this->ftype << endl;
                     cout << "Ctl Period Len:  " << this->ctl_period_len << endl;
                     cout << "Notes:           " << this->notes << endl;
                     cout << endl;
                   };

   public:
      string   path;
      string   fname;
      string   cmplt_name;
      string   info_path;
      string   info_file;
      string   changes_path;
      string   changes_file;
      int      pmark;
      int      ctl_period_len = 0;
      int      num_cells = 0;
      int      cco2stim_code = 0;   // optional carotid
      int      cco2stim_interval = 0;
      int      cco2marker_count = 0;
      int      vco2stim_code = 0;   // optional vertebral
      int      vco2stim_interval = 0;
      int      vco2marker_count = 0;
      int      tb_cgh_stim_code = 0;     // optional cough
      int      tb_cgh_ctl_interval = 0;  // cough uses time for ctl
      int      tb_cgh_stim_cycles = 0;   // and # of cycles for stim
      int      lar_cgh_stim_code = 0;    // optional cough
      int      lar_cgh_ctl_interval = 0; // cough uses time for ctl
      int      lar_cgh_stim_cycles = 0;  // and # of cycles for stim
      int      tb_cghmarker_count = 0;
      int      lar_cghmarker_count = 0;
      int      swall1_start_code=0;
      int      swall1_end_code=0;
      int      swall1_end_count=0;
      int      swall1marker_s_count = 0;
      int      swall1marker_e_count = 0;
      int      lareflex_start_code=0;
      int      lareflex_end_code=0;
      int      lareflex_end_count=0;
      int      lareflexmarker_s_count = 0;
      int      lareflexmarker_e_count = 0;
      bool     have_markers = false;
      string   vagotomized;
      string   notes;
      F_TYPE   ftype;
      ReMap    remap;
};

using VFiles = vector <FileFacts>;
using VFilesIter = vector <FileFacts>::iterator;

/* One text line of .?dt data, hopefully "chan[5]time[10]"
   Update: Learned recently bdt files are "chan[5]time[8]"
           The second substr will read to end of line, so
           nothing to fix, but worth noting this here.
*/
class DataLine
{
  public:
     DataLine() {}
     DataLine(string& line)
     {
        chan_str = line.substr(0,5);
        chan = atol(chan_str.c_str());  // no error checking
        time_str = line.substr(5,10);
        time = atol(time_str.c_str());
     }

     void RemapChan(string& line, long remap)
     {
        chan_str = to_string(remap);
        chan = remap;
     }

     unsigned long GetTime()  { return time; }
     long GetChan()  { return chan; }
     bool IsEPhase() { return chan == E_MARKER; }
     bool IsIPhase() { return chan == I_MARKER; }
     bool IsNeuron() { return chan >= MIN_CELL && chan <= MAX_CELL; }
     bool IsMarker(long marker) { return chan == marker; }

   private:
      string time_str="";
      string chan_str="";
      unsigned long time=0;
      long chan=0;
};


/*  How classes fit together]
     AllBins (map, indexed by [fname], each fname entry contains FBins for the fname)
       [fname0] -> FBins (map, composite index [neuron chan,period], contains bins)
                 -> [chan,period],NeuroBins-> i_bins[]
                                                 OneBin 
                                                 OneBin
                                                   ...
                                               e_bins[]
                                                 OneBin 
                                                 OneBin
                                                   ...
       [fname1] -> FBins 
       [fname2] -> FBins 
          ...
*/

/* We add a NeuroBin to the map container as we find new neurons in a file stream 
   in the current peroid.  Next period creates a new NeuroBin for that period's data.
   Key is composite of chan # and period #.
   Assumes no duplicate chan #'s in a file.
*/
class NeuroBins;
using FBins = map <pair<long,long>, NeuroBins>;
using FBinsIter = FBins::iterator;
using FBinKey = pair<long,long>;

/* One map entry per file, the key is the path/filename
   Holds a bunch of NeuroBins for each file.
*/
using AllBins = map <string,FBins>;
using AllBinsIter = AllBins::iterator;

// info global to each period in each file
class PeriodInfo;
using PerKey = pair <string,int>;
using PerPeriod = map <PerKey,PeriodInfo>; 
using PerPeriodIter = PerPeriod::iterator;
using PerPeriodRet = pair<PerPeriodIter,bool>;

/* A single bin.  We accumulate time, spike counts, and other useful bits of info.
   Algorithm for mean rate is:
        (n0/t0 + n1/t1 + n2/t2 . . .) / num of cycles
   That is, mean of the phase normalized spikes/second.
*/
class OneBin
{
   public:
      OneBin():time(0.0),spikes(0),rate(0.0), mean_rate(0.0), convert(0.0), 
               total_spikes(0), mean(0.0), mean_sqr(0.0), sd(0.0), std_err(0.0),
               scaled_std_err(0.0), scaled_mean_rate(0.0), scale(1.0), period(0) {}

      OneBin(double t, double sec, int p): time(t),spikes(0),rate(0),
                                  mean_rate(0), convert(sec),total_spikes(0),
                                  mean(0.0), mean_sqr(0.0), sd(0.0), std_err(0.0),
                                  scaled_std_err(0.0), scaled_mean_rate(0.0), scale(1.0),
                                  period(p) {}
               
      virtual ~OneBin() {}
      void SetBinTime(double t, double cvt) { time = t; convert = cvt;}
      void IncSpike() { ++spikes; ++total_spikes; }
      unsigned long GetSpikes() {return spikes;}
      void ResetSpike() { spikes = 0; }
      double GetRate() { return rate;}
      double GetMeanRate() { return mean_rate;}
      double GetSD() { return sd;}
      double GetStdErr() { return std_err;}
      double GetStdCalcMean() { return mean;}
      unsigned long GetTotalSpikes() { return total_spikes; }
      void SetScaledVars(double s) { scale = s; 
                                     scaled_std_err = std_err * s; 
                                     scaled_mean_rate = mean_rate * s; }
      double GetScaledStdErr() { return scaled_std_err; }
      double GetScaledMeanRate() { return scaled_mean_rate; }
      double GetScale() { return scale; }
      void UpdateBinStats(PeriodInfo&);
      void CalcBinStats(PeriodInfo&);
      int GetPeriod() { return period; }

   private:
      double time;          // current bin width in file time units, 
                            // varies from cycle to cycle
      unsigned long spikes;
      double rate;         // in spikes/second
      double mean_rate;
      double convert;      // secs/tick, e.g. edt = 0.1
      unsigned long total_spikes;
      double mean;
      double mean_sqr;
      double sd;
      double std_err;
      double scaled_std_err;
      double scaled_mean_rate;
      double scale;
      int    period;
};
using BinArray = vector <OneBin>;
using BinArrayIter = vector <OneBin>::iterator;

// Store data in the current phase that occurs at the same time that the
// next phase starts for inclusion in the next phase.
using DStack = stack <DataLine>;

// Each period has its own number of cycles.  Keep them here.
using CyclesInPeriod = vector <long>;

// If putting periods in separate files, need file offsets.
using PerSeek = vector <streampos>;

// Some cths have stereotaxic 3d coordinates of where the electrode was placed.
class StCoords 
{
   public:

   StCoords() : rl(0.0), dp(0.0), ap(0.0), dchan("0"), mchan("0"), ref("0"), name("not_available"),expname("not_available") {};

   double rl;
   double dp;
   double ap;
   string dchan;
   string mchan;
   string ref;
   string name;
   string expname;
   string expbasename;
   double rl_atlas;
   double dp_atlas;
   double ap_atlas;
};

using CellCoords = map <int,StCoords>;
using CellCoordsIter = CellCoords::iterator;

// We need to use an external tool to turn the stereotaxic coords into
// something the brainstem program can use.
class ACoords
{
   public:
      double ap;
      double rl;
      double dp;
};

// indexed by chan # in the *info*.xls file 
using AtlasCoords = map <int,ACoords>;
using AtlasCoordsIter = AtlasCoords::iterator;


using PhaseHist = map <int,int>;
using PhaseHistIter = PhaseHist::iterator;

using OneTick = vector<long>;
using OneTickIter = vector<long>::iterator;

/* This is a collection of bins and info about them.
   There will be one of these per spike channel in the files.
   The default is 10 e and 10 i bins, but can be any number (and can even be
   different.) 
   The e and i bin values create n-dimensional points that we save to a file.
   There are two sets of bins.  
   The first contains values that result in mean rates per bin for each channel.
   These are N dimensional points used to plot CTH historgrams and for clustering.
   The second contains spike counts using bins that are one tick in width.
   These are used to perform a poisson curve fitting of each CTH by an external R program.
*/

class NeuroBins
{
   friend OneBin;

   public:
      NeuroBins(int c_num, StCoords coords, int per, double e_t, double i_t, double s_per_t)
      {
         chan = c_num;
         period = per;
         cell_coords = coords;
         e_bins.assign(num_e_bins,OneBin(e_t,s_per_t,period)); // create BinArrays
         i_bins.assign(num_i_bins,OneBin(i_t,s_per_t,period));
         is_sparse = false;
      }
      virtual ~NeuroBins () {}

      static bool FindPhaseMarks(ifstream&,long, AllBinsIter&, PeriodInfo&);
      static bool FindCtlStimMarks(ifstream&, int, int, AllBinsIter&, PeriodInfo&, int post_cycles=0);
      static bool FindSwall1Marks(ifstream&, int, int, PeriodInfo&);
      static void ResetPeriodTimes() { period_start = period_end = 0;}
      static void PeriodStart(unsigned long p_s) { period_start = p_s; if (Debug) cout << "PS: " << p_s << endl; }
      static void PeriodEnd(unsigned long p_e) { period_end = p_e; if (Debug) cout << "PE: " << p_e << endl; }
      static void SetSecsTick(double s_p_t) { secs_per_tick = s_p_t; if (Debug) cout << "SPT: " << s_p_t << endl; }
      static double GetSecsTick() {return secs_per_tick;}
      static void SetNumEBins(int e_b)  {num_e_bins = e_b;}
      static void SetNumIBins(int i_b)  {num_i_bins = i_b;}
      static double GetETime()  {return e_time;}
      static double GetITime()  {return i_time;}
      static int GetEPTime()  {return ep_time;}
      static int GetIPTime()  {return ip_time;}
      static bool UseCycle(PeriodInfo&);
      static void PeriodCalcs(PerPeriodIter&);
      static void UpdatePHist(int);

      size_t GetNumIBins() {return i_bins.size();}
      size_t GetNumEBins() {return e_bins.size();}
      void UpdateI(DataLine&);
      void UpdateE(DataLine&);
      void UpdateS(DataLine&);
      void UpdateBinRates(PeriodInfo&);
      void UpdateBinTimes();
      void UpdateBinAmpl();
      void Stats(PeriodInfo&);
      int  GetChan() { return chan; }
      void CreateOneTickBins(long i,long e) {i_onetick.assign(i,0);e_onetick.assign(e,0);}
      void UpdateI_OT(DataLine&);  // one tick
      void UpdateE_OT(DataLine&);
      void UpdateS_OT(DataLine&);

      static void PrintPeriodTime() {if (period_end-period_start) { int time = (period_end - period_start) * secs_per_tick/1000; cout << "Period Time: " << time << " sec.  " << time/60 << " min." << endl;} }
      void PrintIBins();
      void PrintEBins() ;
      void PrintITickBins();
      void PrintETickBins() ;
      void WriteSBins(ofstream& out);
      void WriteOneTicks(ofstream& out);
      void WriteOneTickBins(ofstream& out, int);

      double GetBinPeak();
      double GetBinMeans();
      void CheckScale(double,double);
      void SetScale(double scale);
      unsigned long GetTotalSpikes();
      double GetScale() { return i_bins[0].GetScale();} // same for all bins
      double GetIMeanRate(int idx) { return i_bins[idx].GetMeanRate(); };
      double GetEMeanRate(int idx) { return e_bins[idx].GetMeanRate(); };
      double GetISD(int idx) { return i_bins[idx].GetSD(); };
      double GetESD(int idx) { return e_bins[idx].GetSD(); };
      double GetIStdErr(int idx) { return i_bins[idx].GetStdErr(); };
      double GetEStdErr(int idx) { return e_bins[idx].GetStdErr(); };
      double GetIScaledStdErr(int idx) { return i_bins[idx].GetScaledStdErr(); };
      double GetEScaledStdErr(int idx) { return e_bins[idx].GetScaledStdErr(); };
      long GetPeriod() { return period; }
      void SetSparse() { is_sparse = true;}
      void UnSetSparse() { is_sparse = false;}
      bool IsSparse() { return is_sparse;}
      StCoords GetCoords() { return cell_coords; }
      void WriteOctaveHeader(ofstream &, string, string, int, int, int);
      void WriteOEBins(ofstream &);
      void WriteOIBins(ofstream &);
      void WriteOStats(ofstream&, int);
      void WriteOCoords(ofstream&);
      void WriteDistStats(ofstream&);
      void WriteRVals(ofstream&, CTHCurves&, string&);
      void WriteOSparse(ofstream& out);
      void WriteOExpName(ofstream&, string, int);
      void WriteCEBins(ofstream &);
      void WriteCIBins(ofstream &);
      void WriteGCHeader(ofstream &);
      void WriteGCEBins(ofstream &);
      void WriteGCIBins(ofstream &, int);
      static void WriteOVersion(ofstream &); // don't need instance data
      static void WriteOEndMark(ofstream &);

          // manage stacked events for next phase, rates
      bool HaveE() { return !saved_e.empty(); }
      bool HaveI() { return !saved_i.empty(); }
      void SaveForE(DataLine d) { saved_e.push(d); }
      void SaveForI(DataLine d) { saved_i.push(d); }
      DataLine& GetE() { return  saved_e.top();}
      DataLine& GetI() { return  saved_i.top();}
      void RemoveE() { saved_e.pop(); }
      void RemoveI() { saved_i.pop(); }

          // manage stacked events for next phase, one tick bins
      bool HaveE_OT() { return !saved_e_onetick.empty(); }
      bool HaveI_OT() { return !saved_i_onetick.empty(); }
      void SaveForE_OT(DataLine d) { saved_e_onetick.push(d); }
      void SaveForI_OT(DataLine d) { saved_i_onetick.push(d); }
      DataLine& GetE_OT() { return  saved_e_onetick.top();}
      DataLine& GetI_OT() { return  saved_i_onetick.top();}
      void RemoveE_OT() { saved_e_onetick.pop(); }
      void RemoveI_OT() { saved_i_onetick.pop(); }

   private:
      NeuroBins(){}
       // rate accumulators
      BinArray e_bins;  // bin data managed by these
      BinArray i_bins;
      DStack saved_e;   // boundary events that belong in
      DStack saved_i;   // next phase goes into these

      // one-tick  accumulators
      OneTick i_onetick;
      OneTick e_onetick;
      DStack saved_e_onetick;   // boundary events that belong in
      DStack saved_i_onetick;   // next phase goes into these

      int chan;
      int period;
      StCoords cell_coords;  // optional stereotaxic coordinates
      bool is_sparse;

        // globals shared by all bin object instances
      static long i_start;      // time of current i phase in file time units
      static long e_start;      // time of current e phase
      static long next_i;       // time of next e phase
      static long period_start; // start and end of current period
      static long period_end;
      static unsigned long stim_end;
      static CyclesInPeriod num_cycles; // total number of cycles we accumulated 
                                        // counts for in periods in a file
      static unsigned int num_i_bins;
      static unsigned int num_e_bins;
      static double i_time; // width of bins in file time units
      static double e_time;      
      static long  ip_time;     // width of current i phase in file ticks
      static long  ep_time;     // for one tick bin operations

      static double secs_per_tick;  // file secs/tick (.1, .5)
};
      

// Utility class to info global to each period.
class PeriodInfo
{
   public:
      PeriodInfo(int per) {Reset(); period = per;}
      virtual ~PeriodInfo() {}

      void Reset() {i_short=i_max=e_short=e_max=
                    i_min_tossed=i_max_tossed=e_min_tossed=e_max_tossed=
                    total_accept=total_reject=num_cycles=0;max_cth=0.0;}
      void Report() { cout <<  "Total cycles: " << num_cycles << endl <<
                      "Rejected " << total_reject << " cycles" << endl  <<
                      "Accepted " << total_accept << " cycles (" << 
                      100.0 * total_accept / num_cycles << "%)" << endl <<
                      "Less than min I: " << i_min_tossed  << 
                      "  Greater than max I: " << i_max_tossed << endl <<
                      "Less than min E: " << e_min_tossed  << 
                      "  Greater than max E: " << e_max_tossed << endl; }

      int period;   // who are we?

           // on tick bin vars
      long i_short;   // bin min and max widths, in ticks
      long i_max;
      long e_short;
      long e_max;

      long i_min_tossed;      // keep track of tossed/kept cycles
      long i_max_tossed;
      long e_min_tossed;
      long e_max_tossed;
      long total_accept;
      long total_reject;

         // other
      long num_cycles;       // number of cycles in this period
      double max_cth;        // largest cth spikes/sec for this period
};

#endif
